## Что такое статическая и динамическая типизация и в чем это проявляется в Python?

В языках со **статической типизацией** тип **связан с переменной**, и этот тип известен ещё до запуска программы. Это означает, что при объявлении переменной нужно указать её тип (или он выводится автоматически), и потом в эту переменную можно присваивать только значения **совместимого типа**. Оператор присваивания `=` записывает значение в переменную, и компилятор заранее проверяет, можно ли это сделать. Благодаря этому многие ошибки выявляются **до запуска программы**.

В языках с **динамической типизацией**, таких как `Python`, тип **хранится не в переменной, а в объекте** (значении). Переменная просто **ссылается на объект**, и не "знает", какого он типа. Когда используется оператор присваивания `=`, имя (то, что мы называем переменной) просто начинает указывать на объект. Если имя используется впервые, оно создаётся и сразу ссылается на объект. Если оно уже существовало - указывает на новый объект. Из-за этого в `Python` переменные иногда называют **именами**, **ссылками** или **идентификаторами**, подчёркивая, что они не хранят данные сами по себе, а лишь указывают на объекты в памяти.

## Что такое утиная типизация?

Концепция, характерная для языков программирования с динамической типизацией, согласно которой конкретный тип или класс объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает.

Типизацию называют утиной в честь известного “утиного теста”:

> Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка.

Такой подход добавляет гибкости коду, позволяет полиморфно работать с объектами, которые никак не связаны друг с другом и могут быть объектами разных классов. Единственное условие, чтобы все эти объекты поддерживали необходимый набор свойств и методов.

В примере ниже функции `len` не важен тип аргумента, а важно лишь то, что у объекта можно вызвать метод `__len__()`.

```python
class Meter:
	def __len__(self):
		return 1_000


len([1, 2, 3]) -> 3
len("Duck typing...") -> 14
len(Meter()) -> 1000
```

## Какие типы данных в Python вам известны?

В `python` все типы объектов можно разделить на два вида: **изменяемые** (`mutable`) и **неизменяемые** (`immutable`).

Значение, хранящееся в объекте **неизменяемого типа**, невозможно изменить никакими способами. Единственный способ получить объект такого типа с другим значением — создать новый объект с нужным значением. К таким типам относятся **примитивы** (целые числа, числа с плавающей точкой, булевы значения, строки), **кортежи**.

Значение, хранящееся в объекте **изменяемого типа**, можно изменить не создавая новый объект. Изменения объекта возможно за счет вызова его методов или применения к нему операторов. К таким типам относятся **множества**, **списки**, **словари**.

## `==` vs `is`

Оператор `==` проверяет, **равны ли значения** двух объектов. Оператор `is` проверяет, **один и тот же это объект в памяти или нет**. Для строк и чисел см. инт
```python
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b)  # True, потому что содержимое списков одинаковое
print(a is b)  # False, потому что это два разных списка (разные объекты в памяти)
```

## `copy` vs `deepcopy`

`copy.copy()` — **поверхностная копия**. Создаёт **новый объект верхнего уровня**, но **вложенные объекты не копирует**, а просто ссылается на них.

`copy.deepcopy()` — **глубокая копия**. Создаёт **новый объект и рекурсивно копирует всё содержимое**, включая все вложенные объекты.
```python
import copy

# copy.copy()
original = [[1, 2], [3, 4]]
shallow = copy.copy(original)

print(original == shallow)        # True — значения одинаковые
print(original is shallow)        # False — это разные списки
print(original[0] is shallow[0])  # True — вложенные списки одинаковые

shallow[0][0] = 99
print(original)  # [[99, 2], [3, 4]] — оригинал тоже изменился!

# copy.deepcopy()
original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)

deep[0][0] = 99
print(original)  # [[1, 2], [3, 4]] — оригинал не изменился
```

## Что такое коллекция?

Коллекция — объект, который одновременно является **контейнером**, **итерируемым объектом** и **объектом ограниченной длины**.

Объект считается **контейнером** (**`Container`**), если у него можно спросить, содержит ли он какой-то произвольный элемент `x`. Иными словами, если `A` контейнер, то для любого `x` следующее выражение должно вычисляться без ошибок и возвращать булевое значение: `x in A`.

Объект считается **итерируемым** (**`Iterable`**), если по нему можно пробежаться в цикле (**`iterate` over**). Т.е. `A` — итерируемый объект, если можно написать следующее выражение: `for x in A:`.

Объект считается **объектом ограниченной длины** (**`Sized`**), если у него можно спросить количество элементов (длина, размер, **`size`**) функцией len. Т.е. `A` — объект ограниченной длинны, если `len(A)` вычисляется без ошибок и возвращает целое неотрицательное число.

Коллекции (`Collection`) делятся на классы — последовательности (`Sequence`), отображения (`Mapping`), множества (`Set`) и другие.

## Что такое последовательность?

Коллекция является последовательностью, если элементы этой коллекции упорядочены. Следствием этого свойства является возможность индексации последовательности по порядковому номеру элемента (по смещению, по целочисленному индексу), т.е. у любой последовательности можно спросить её i-й элемент.